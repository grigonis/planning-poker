const { rooms, createRoom, getRoom, deleteRoom } = require("../store");

module.exports = (io, socket) => {
    const joinRoom = ({ roomId, userId, name, role }) => {
        // If room doesn't exist, create it (or logic could specific host must create first)
        // For specific "Host creates, Voter joins" flow:
        // We might want separate createRoom event. But typical poker apps just "join" and if new -> create.
        // However, requirements say "Host creates".
        // Let's assume simpler: Join creates if not exists, but distinct Host vs Voter flows might need flags.
        // Actually, distinct roles: Host doesn't vote.
        // Let's pass `isHost` flag or infer from creation.

        // Better: Room ID is generated by Host. Host calls 'create_room'.
        // Voter calls 'join_room'.
        // But for MVP, 'join' with a roomID is standard.
        // Let's support 'create_room' explicit event for Host.
    };

    const createRoomHandler = (callback) => {
        const roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
        const room = createRoom(roomId, socket.id);
        socket.join(roomId);

        // Host is automatically a "user" but maybe "spectator" role? 
        // "Host does not vote".
        room.users.set(socket.id, {
            id: socket.id,
            name: "Host",
            role: "HOST",
            connected: true,
            socketId: socket.id
        });

        callback({ roomId, userId: socket.id });
        console.log(`Room created: ${roomId} by ${socket.id}`);
    };

    const joinRoomHandler = ({ roomId, name, role }, callback) => {
        const room = getRoom(roomId);
        if (!room) {
            return callback({ error: "Room not found" });
        }

        // Reconnection logic could go here (match by name?)
        // For now, new user.
        const user = {
            id: socket.id,
            name,
            role, // 'DEV' | 'QA'
            connected: true,
            socketId: socket.id
        };

        room.users.set(socket.id, user);
        socket.join(roomId);

        // Notify others
        io.to(roomId).emit("user_joined", Array.from(room.users.values()));

        // Send current state to joiner
        callback({
            success: true,
            phase: room.phase,
            users: Array.from(room.users.values()),
            votes: Array.from(room.votes.entries()) // Maybe hide values if Phase is Voting?
        });

        console.log(`${name} joined ${roomId} as ${role}`);
    };

    socket.on("create_room", createRoomHandler);
    socket.on("join_room", joinRoomHandler);
};
